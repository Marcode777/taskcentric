<!-- *******IT'S ALL ABOUT COMPONENTS, STATES AND PROPS, and remember that a render can only essentially display 1 parent element, if we want to render multiple parent elements, they have to be wrapped in a div. Remember to use ".bind(this)" when passing functions or methods around. Whenever we're binding a value, we'll also set up a change listener for that, so that it actually changes when the value changes. Also, css-like design elements with hyphens are camelCase in React JSX and should be made into a component, and then implemented, in order for them to function.*******
******FLUX is a pattern. CADS, Components, Actions, Dispatcher, Stores and it cycles again.******
******Remember, when listening to events on mount, to also unmount them to prevent memory leaks.******
*****The simplest components in react are just like functions, 
but the reason you'd want to use class is that it has access to component life cycles.*****
*****props are actually just JavaScript objects that are converted by Babel and written in JSX, and are given as arguments, e.g. function MonsterList(props), so that way we have, available, props.monsters*****
***** also, the curly braces { }, in JSX means, between these curly braces, perform JavaScript. If you remove the curly braces, they would just get rendered straight as text.*****
***** componentWillMount() life cycle hook initializes the state of our app at the beginning*****
*****make sure you know what you are exporting, e.g., you have multiple components, but there is a main component that it should be contained in, so export that. For example, if your main component is class App, export default App, or if it is class Monster, then export default class Monster*****


to use this app, run the command webpack-dev-server, and it should display on localhost 8080;

left off at 51:25

to use this app, on terminal, run webpack-dev-server and app should appear on localhost:8080

npm init -y to create package.json

npm i -S react, react-dom    (npm i -S, is a quick way of npm install --save)

npm i -D babel-core babel-loader babel-preset-es2015 babel-preset-react react-hot-loader webpack webpack-dev-server                    (npm i -D, is a quick way of npm install --save-dev)

then npm i -g webpack webpack-dev-server (npm i -g, is a quick way of npm installing globally)

sidenote: for the webpack.config.js file, differences are in loaders, instead of react-hot it is react-hot-loader/webpack, but here I revised it yet again from react-hot-loader/webpack to react-hot-loader

To create a production bundle, use `npm run build`.



*the difference between just exporting class and using ,export default class, is that if you just export class, then you have to import them using their exact names in between curly braces as in, export class Display will have to be imported as import {Display} from './whateverfile', while using export default class Display can be imported as, import Display from './whateverfile' and also you can import default and named exports at the same time,
import Template,{AnotherTemplate} from './components/templates'* 
*also as a note, the default export class name has to be the same as the actual file name it's coming from, except the first letter is capitalized, and then this is also the same name, except capilaized, that must be imported as well*
* also, the simplest REACT components are functions, but class is used for when component life cycle hooks are needed, such as componentWillMount()*


CSS Pre-processors such as LESS or SASS help the app load faster via imports, giving the ability to collect multiple documents and collect them together and output them as one file, because each document you link to in the head of the HTML is an HTTP request, this lessens the amount of HTTP requests into one, thereby giving the app more speed. They also help lessen total code.

JSON example:
     {
"employees":[
    {"firstName":"John", "lastName":"Doe"}, 
    {"firstName":"Anna", "lastName":"Smith"},
    {"firstName":"Peter", "lastName":"Jones"}
]
}